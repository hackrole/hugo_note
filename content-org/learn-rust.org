#+STARTUP: content

#+hugo_base_dir: ../
#+hugo_section: posts
#+hugo_weight: auto
#+hugo_auto_set_lastmod: t

* learn rust notebook                                                  :@Rust:

** TODO 14章命名空间
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-note-14
:EXPORT_DATE: 2020-11-01
:END:

workspace(工作空间)讲多个crates合并到一个项目中,

是否有只能有多个bin-crate和一个lib-crate限制?

#+begin_src toml :output result :export both
  // add/Cargo.toml
  // workspace need a special Cargo.toml which only contains workspace
  [workspace]
  members = [
      "adder"
  ]

  // every project in current workspace need own Cargo.toml
  // projects will share root directory Cargo.lock to make
  // every project have same lib versioin.
  [depencencies]
  add-one = { path: "../add-one"}
#+end_src

#+begin_src rust :output result :export both
  // add-one/lib.rs
  pub fn add_one(x: i32) -> i32 {
      x + 1
  }

  #[cfg(test)]
  mod tests {
      use super::*;

      #[test]
      fn it_works() {
          assert_eq!(3, add_one(2))
      }
  }
#+end_src

#+begin_src rust :output result :export both
  // adder main.rust
  use add_one;

  fn main(){
      let num = 10;
      println!("Hello, world! {} plus one is {}!", num, add_one::add_one(num));
  }
#+end_src

使用cargo build -p <project>来build特定项目

发布需要进入每个单独的项目做发布，没有-p/--all参数

*** cargo install
`cargo install` 默认安装到~/.carog/bin目录，只能安装bin-crates.

*** cargo submodule
定义命令名为cargo-<command>的命令可以作为cargo子命令运行

** TODO 15 smart-point(智能指针)
:PROPERTIES:
:EXPORT_FILE_NAME: learn-rust-note-15-smart-point
:EXPORT_DATE: 2020-11-01
:END:

*** introduce
智能指针也是一类指针，但是拥有额外的元数据和功能。
比如 reference-count(引用计数)只能指针, 允许数据有多个所有者，记录共多少个所有者，在没有所有者时清理数据
String和Vec<T>也是智能指针，有元数据(容量等)和额外的功能(方法)

智能指针通常使用struct实现,一般是要实现Deref和Drop trait
智能指针是Rust常用的通用设计模式，很多库会有自己的智能指针，也可以编写自己的智能指针.

这里主要讨论最常用的智能指针:
1. Box<T> 用于在堆上分配值
2. Rc<T> 一个引用计数类型,数据可以有多个所有者
3. Ref<T>和RefMut<T>, 通过RefCell<T>访问. RefCell<T>是一个在运行时而不是编译时执行的借用规则的类型。

另外需要涉及 **内部可变性** (interior mutability)模式
已经 **引用循环** (reference cycles), 会泄漏内存，已经如何避免

*** Box<T>使用堆上的数据
使用场景:
1. 编译时未知大小的类型，由想要在需要确切大小的上下文中使用这个类型值
2. 多有大量数据，需要确保在数据不被copy的情况下转移所有权
3. 当希望一个值只关心他的类型是否实现特定的trait，而不是具体类型

#+begin_src rust :output result :export both
  fn main() {
      let b = Box::new(5);
      println!("b = {}", b);
  }
#+end_src

#+begin_src rust
  // use rust to define a recursive Type.
  // Recursive-Type can ref itself, so cannot get it size in build-time.
  enum List {
      Cons(i32, Box<List>),
      Nil
  }

  use crate::List::{Cons, Nil};

  fn main() {
      let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3), Box::new(Nil))));
  }
#+end_src

*** Deref Trait将智能指针当作常规引用处理

#+begin_src rust
  struct MyBox<T>(T);

  impl<T> MyBox<T> {
      fn new(x: T) -> MyBox<T> {
          MyBox(x)
      }
  }
#+end_src

** 16 无畏并发 fearless concurrency
   :PROPERTIES:
   :EXPORT_FILE_NAME: learn-rust-note-16-concurrency
   :EXPORT_DATE: 2020-11-04
   :END:
  
   concurrent-programming: programs can run in independent with each other.
   parallel programming: program can run at same time.

   as a low-level language, rust need less abstraction and more control.
   
*** use thread

    process vs thread

    programs:

    1)  Race conditions: data-race. resource-race.
    2)  DeakLock
    3)  difficult concurrent bug.

    os-thread vs green-thread: 1:1 vs M:N

    #+begin_src rust
    /// thread examples

    /// when the main-thread exit, the fork-thread will exit too.
    /// just like python thread.deamon flag.

    use std::thread;
    use std::time::Duration;

    fn main() {
        thread::spawn(|| {
            for i in 1..10 {
                println!("hi number {} from the spawned thread!", i);
                thread::sleep(Duration::from_millis(1));
            }
        });

        for i in 1..5 {
            println!("hi number {} from the main thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    }
    #+end_src

    #+begin_src rust
    /// use join to wait sub-thread finish
    use std::thread;
    use std::time::Duration;

    fn main() {
        let handle = thread::spawn(|| {
            for i in 1..10 {
                println!("hi number {} from the spawned thread!", i);
                thread::sleep(Duration::from_millis(1));
            };
        });

        for i in 1..5 {
            println!("hi number {} from the main thread!", i);
            thread::sleep(Duration::from_millis(1));
        }

        handle.join().unwrap();
    }
    ```

    thread vs move-closure

    ```rust
    use std::thread;

    fn main() {
        let v = vec![1, 2, 3];

        /// this would raise, cause the `v` was a borrow-ref.
        /// it may be dropped before sub-thread. rust avoid you to do this.
        // let handle = thread::spawn(|| {
        //     println!("Here's a vector: {:?}", v);
        // });

        /// add `move` to move owner to sub-thread.
        let handle = thread::spawn(move || {
            println!("Here's a vector: {:?}", v);
        });

        /// the would made `v` not exists in sub-thread.
        /// if variables has been moved into sub-thread, this would raise too.
        // drop(v)


        handle.join().unwrap();
    }

    #+end_src


*** pass msg between threads

    #+begin_src rust
    use std::thread;
    use std::sync::mpsc;

    fn main() {
        let (tx, rx) = mpsc::channel();

        thread::spawn(move || {
            let val = String::from("HI");
            tx.send(val).unwrap();
        });

        let received = rx.recv().unwrap();
        println!("Got: {}", received);
    }
    #+end_src

    #+begin_src rust
    use std::thread;
    use std::sync::mpsc;
    use std::time::Duratin;

    fn single_send() {
        let (tx, rx) = mpsc::channel();

        thread::spawn(move || {
            let vals = vec![
                String::from("Hi"),
                String::from("from"),
                String::from("the"),
                String::from("thread"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                thread::sleep(Duratin::from_secs(1));
            }
        });

        for received in rx {
            println!("Got: {}", received);
        }
    }

    fn multi_send() {
        let (tx, rx) = mpsc::channel();

        // use clone to got multi sender
        let tx1 = mpsc::Sender::clone(&tx);
        thread::spawn(move || {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("thread"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                thread::sleep(Duration::from_secs(1));
            }
        });

        thread::spawn(move || {
            let vals = vec![
                String::from("move"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];
            for val in vals {
                tx.send(val).unwrap();
                thread::sleep(Duration::from_secs(1));
            }
        });

        for received in rx {
            println!("Got: {}", received);
        }
    }

    #+end_src

*** share-memory concurrent

    channel is like single-owner ref.
    share-memory is like multi-owner ref.
    rust type-system and owner-rule can help correctly manage those.

    mutex(互斥器) mutual-exclusion abbs.
    mutex usually stay with data, use the lock to guarding its data.

    correctly use mutex, you need

    1)  request lock before use data.
    2)  after use data, you must release the lock.

    #+begin_src rust
    use std::sync::Mutex;

    fn main() {
        let m = Mutex::new(5);

        {
            let mut num = m.lock().unwrap();
            *num = 6;
        }

        println!("m = {:?}", m);
    }

    #+end_src

    #+begin_src rust
    /// multi-thread mutex example
    // use std::rc:Rc;
    use std::sync::{Mutex, Arc};
    use std::thread;

    fn main() {
        /// this would compile, cause counter with move cannot have multi-owner
        // let counter = Mutex::new(0);
        /// this would compile failed, cause Rc is not thread-safe.
        // let counter = Rc::new(Mutex::new(0));
        /// Arc is thread-safe Ac-Ref
        let counter = Arc::new(Mutex::new(0));
        let mut handles = vec![];

        for _ in 0..10 {
            let counter = Arc::clone(&counter);
            let handlet = thread::spawn(move || {
                let mut num = counter.lock.unwrap();
                *num += 1;
            });
            handles.push(handle);
        }

        for handle in handles {
            handle.join().unwrap();
        }

        println!("Result: {}", *counter.lock().unwrap());
    }

    #+end_src

    Mutex提供了类似Cell<T>的内部可变性，可以修改非mut类型的值.
    Rust不能避免Mutex的所有逻辑错误.

    #+begin_src rust
    /// TODO: add a dead-lock rust Mutex programming.
    #+end_src

    Mutex<T> vs MutexGuard<T>
    
*** 使用Sync and Send trait的可扩展并发

    Rust提供于golang相反的设计，语言本身不提供并发相关内容, 并发功能由库来提供和扩展。
    然后有两个概念内嵌语言中: `std::marker`的 `Sync` 和 `Send` trait.

    marker-trait: 标记类型, 不需要实现trait-method
    implement this need write unsafe-rust-code.

    1)  Send-Trait mark Type can move owner-right between thread.
    2)  Almost all rust Type implement Send-Trait.
    3)  Some speical example like Rc<T> is design for single-thread, Arc<T> is its thread-safe version.
    4)  Any Type which contains only Send-Type auto become Send-Type.
    5)  Sync-Trait mark Type can be used safely in multiple-thread env.
    6)  for Type T, if &T is Send-Trait, T is Sync-Trait.
    7)  Type make of Sync-Type auto become Sync-Type.

** 17 rust OOP
   :PROPERTIES:
   :EXPORT_FILE_NAME: learn-rust-17-rust-oop
   :EXPORT_DATE: 2020-11-04
   :END:
   
   1) rust can bind data with methods
   2) rust can use pub/private to abstract inner implement.
   3) rust not support exntends. you should consider use combination more.

   extend has two more usage-point.
   1) reuse pub method from parent-class or ability to rewrite it on willing. Rust use Trait to do this.
   2) polymorphism. Parent-Ref can ref any-SubType-instances, and method-call is eval at runtime.in Rust, you may use Generics-Type and Trait-Bounds todo this. \`bounded parametric polymorphism\`.

*** TODO Trait-object used for instances with different types
    Generic and Trait-Bound can only replace one type.会在编译时做单态化，所以无法在Vec中存放多种类型.即静态分发(static dispatch)
    在Vec中存放Tracit配置dyn可以(dynamic dispatch)
    
    ~~object-safe-trait~~:
    1) 返回类型不为self
    2) 方法没有任何泛型类型参数

    #+begin_src rust
      pub trait Draw {
          fn draw(&self);
      }

      pub struct Screen {
          /// dyn keyword
          pub components: Vec<Box<dyn Draw>>,
      }

      impl Screen {
          pub fn run(&self) {
              for component in self.components.iter() {
                  component.draw();
              }
          }
      }

      /// Generic with trait-bound can only static-dispatch
      // pub struct Screen<T: Draw> {
      //     pub components: Vec<T>,
      // }

      // impl<T> Screen<T>
      // where T: Draw{
      //     pub fn run(&self) {
      //         for component in self.components.iter() {
      //             component.draw();
      //         }
      //     }
      // }


      /// add Draw-Trait Type
      pub struct Button {
          pub width: u32,
          pub height: u32,
          pub label: String,
      }

      impl Draw for Button {
          fn draw(&self){
              println!("draw button");
          }
      }


      struct SelectBox {
          width: u32,
          height: u32,
          options: Vec<String>,
      }

      impl Draw for SelectBox {
          fn draw(&self) {
              println!("draw selectbox");
          }
      }
    #+end_src
    
*** 面向对象设计模式的实现
    ~~TODO 状态模式~~

    #+begin_src rust
      use blog::Post;

      fn main() {
          let mut post = Post::new();

          post.add_text("I ate a salad for lunch today");
          assert_eq!("", post.content());

          post.request_review();
          assert_eq!("", post.content());

          post.approve();
          assert_eq!("I ate a salad for lunch today", post.content());
      }


      pub struct Post {
          state: Option<Box<dyn State>>,
          content: String,
      }

      impl Post {
          pub fn new() -> Post {
              Post {
                  state: Some(Box::new(Draft {})),
                  content: String::new(),
              }
          }

          pub fn add_text(&mut self, text: &str) {
              self.content.push_str(text);
          }

          pub fn content(&self) -> &str {
              self.state.as_ref().unwrap().content(self)
          }

          pub fn request_review(&mut self){
              if let Some(s) == self.state.take() {
                  self.state = Some(s.request_review())
              }
          }

          pub fn approve(&mut self) {
              if let Some(s) = self.state.take() {
                  self.state = Some(s.approve())
              }
          }
      }


      trait State {
          fn requet_review(self: Box<Self>) -> Box<dyn State>;
          fn approve(self: Box<Self>) -> Box<dyn State>;
          fn content<'a>(&self, post: &'a Post) -> &'a str {
              ""
          }
      }

      struct Draft {}

      impl State for Draft {
          fn request_review(self: Box<Self>) -> Box<dyn State> {
              Box::new(PendingReview {})
          }

          fn approve(self: Box<Self>) -> Box<dyn State> {
              self
          }
      }

      struct PendingReview {}


      impl State for PendingReview {
          fn request_review(self: Box<Self>) -> Box<dyn State> {
              self
          }

          fn approve(self: Box<Self>) -> Box<dyn State>{
              Box::new(Published {})
          }
      }

      struct Published {}

      impl State for Published {
          fn request_review(self: Box<Self>) -> Box<dyn State> {
              self
          }

          fn approve(self: Box<Self>) -> Box<dyn State> {
              self
          }

          fn content<'a>(&self, post: &'a Post) -> &'a str {
              &post.content
          }
      }
    #+end_src
